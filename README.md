<p align="center">
  <a href="" rel="noopener">
 <img src="http://optimizer.math.sharif.edu/wp-content/uploads/2021/02/optimizer.png" alt="Optimizer logo"></a>
</p>
<h3 align="center">تیم اسپارک</h3>


## 📝 فهرست مطالب
- [صورت‌بندی سوال](#problem_statement)
- [الگوریتم بهینه‌سازی](#idea)
- [محدودیت‌ها](#limitations)
- [ایده‌های گسترش](#future_scope)
- [روند اجرا](#getting_started)
- [نحوه استفاده](#usage)
- [وابستگی‌ها](#tech_stack)
- [نویسندگان](#authors)

## 🧐 صورت‌بندی سوال <a name = "problem_statement"></a>
صورت برنامه‌ریزی :
  
  ```math
  min  ||V||_2,0 
  s.t.  ||(SV)^T||_2,0 <= k 
        L <= V <= U
  ```
  .مطابق راهنمایی های بخش های قبل نرم دو-صفر را با نرم دو-یک جایگزین کردیم 
  سپس مشابه کدی که برای بخش قبلی پیاده سازی کرده بودیم را برای این بخش نیز پیاده سازی کردیم و لامبدا را به صورت پارامتر به برنامه ریزی دادیم.
  برای به دست آوردن لامبدا ابتدا یک حدس معقول برای مقدار لابمدا زدیم و سپس با روش ساده‌ی جستجوی دودویی چند لامبدای دیگر را نیز انتخاب و امتحان کردیم و در نهایت بهترین جواب را برای هر بخش سابمیت کردیم
  
</br>

برای پیدا کردن لامبدا ایده‌ی استفاده از  دوگان را نیز بررسی گردیم اما این روش به جمع بندی نهایی نرسید. زیرا مطابق محاسبات ما لامبدا ی به دست آمده از دوگان یک اسکالر نبود بلکه یک ماتریس بود. همچنین استفاده از میانگین درآیه های ماتریس یا نرمی از ماتیرس نیز مطرح شد که به مرحله ی پیاده سازی نرسید.
  
## 💡 الگوریتم بهینه‌سازی <a name = "idea"></a>
برنامه ریزی مطرح شده در دور قبل را در جومپ پیاده سازی کرده و با سالور
<div>Ipopt</div>
حل کردیم. با این تفاوت که در این بخش لامبدا را خودمان به عنوان پارامتر ورودی تایین کردیم.
</br>
به طور دقیق تر تابع زیر برای هر ستون ماتریس وی اجرا شد. پارامتر زد هم  توسط تابعی مجزا در هر مرحله محاسبه شد. 
```
function opt_vector(S,l,u,z,lambda)
    model = Model(Ipopt.Optimizer)
    
    @variable(model, l[i] <= v[i = 1:r] <= u[i])
    @variable(model,a[1:r])
    @variable(model,b[1:m])
    
    @constraint(model, a .>= v)
    @constraint(model, a .>= -v)
    
    @constraint(model, b .>= S*v)
    @constraint(model, b .>= -S*v)
    
    
    @NLobjective(model,Min,sum(sqrt(1+z[i]+a[i]) for i=1:r) + lambda*sum(b[j] for j=1:m))
    optimize!(model)
    
    return JuMP.value.(v)
  end
```

## ⛓️ محدودیت‌ها <a name = "limitations"></a>
محدودیتی در این بخش وجود ندارد و با نصب
پکیج های مورد نظر 
میتوان یک جواب شدنی برای هر ۳ ورودی مسابقه به دست آورد.
اما زمان مورد نیاز برای ورودی سوم قابل توجه است.

## 🚀 ایده‌های گسترش <a name = "future_scope"></a>
تلاش ما این بود که لامبدا را به صورت تابعی جبری از کا بنویسیم. و یا یک تقریب عددی برای لامبدا به دست آوریم. اما موفق به جمع بندی این روش ها و یافتن ایده ی متفاوت تری نشدیم .

## 🏁 روند اجرا <a name = "getting_started"></a>

### پیش‌نیازها
  

## 🎈 نحوه استفاده <a name="usage"></a>

میتوانید نوتبوک هارا به صورت یکجا یا سلول به سلول اجرا کنید و خروجی در همان مسیر ذخیره میشود.
خواندن ورودی در صورتی که نوتبوک و دیتا در یک پوشه باشند بدون مشکل انجام خواهد شد. اما اگر در پوشه های جداگانه باشند مسیر دیتای ورودی را باید در کد آپدیت کنید.


## ⛏️ وابستگی‌ها <a name = "tech_stack"></a>
  برنامه در زبان جولیا نوشته شده و لیست پکیج های مورد نیاز در ادامه آمده است :
```
  MAT
  JuMP
  GLPK
  Ipopt
  SparseArrays
  DelimitedFiles
```

## ✍️ نویسندگان <a name = "authors"></a>
هر دو عضو تیم به یافتن روش عددی یا جبری برای به دست آوردن لامبدا فکرد کردند. در نهایت کد این بخش که مشابه بخش قبلی بود توسط آیدا افشار محمدیان برای هر ورودی اجرا شد. لامبدا های مختلف  مقایسه و بهترین جواب سابمیت شد.
</br>
استفاده همزمان از گوگل کولب توسط متین امینی امتحان شد که به دلیل سرعت بسیار پایین اجرا، متوقف شد.
